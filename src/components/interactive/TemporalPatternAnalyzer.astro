---
// Temporal Pattern Analyzer - Interactive hour/day violation heatmap
// Based on temporal_patterns.png with enhanced interactivity
export interface TemporalAnalyzerProps {
  height?: number;
  showControls?: boolean;
  allowBrushing?: boolean;
}

interface Props extends TemporalAnalyzerProps {}

const {
  height = 400,
  showControls = true,
  allowBrushing = true
} = Astro.props;
---

<div id="temporal-pattern-analyzer" class="w-full bg-white rounded-lg shadow-lg p-6">
  <div class="mb-6">
    <h3 class="text-2xl font-bold text-gray-900 mb-2">
      Temporal Violation Patterns
    </h3>
    <p class="text-gray-600">
      Interactive analysis of when bus violations occur throughout the day and week
    </p>
  </div>

  {showControls && (
    <div class="mb-6 flex flex-wrap gap-4 items-center">
      <div class="flex items-center gap-2">
        <label for="chart-type" class="text-sm font-medium text-gray-700">View:</label>
        <select id="chart-type" class="px-3 py-2 border border-gray-300 rounded-md text-sm">
          <option value="heatmap">Hour Ã— Day Heatmap</option>
          <option value="hourly">Hourly Patterns</option>
          <option value="daily">Daily Patterns</option>
          <option value="effectiveness">Enforcement Effectiveness</option>
        </select>
      </div>

      <div class="flex items-center gap-2">
        <label for="metric-type" class="text-sm font-medium text-gray-700">Metric:</label>
        <select id="metric-type" class="px-3 py-2 border border-gray-300 rounded-md text-sm">
          <option value="violations">Total Violations</option>
          <option value="rate">Ticketing Rate</option>
          <option value="effectiveness">Enforcement Effectiveness</option>
        </select>
      </div>

      <div class="flex items-center gap-2">
        <label for="route-filter" class="text-sm font-medium text-gray-700">Route:</label>
        <select id="route-filter" class="px-3 py-2 border border-gray-300 rounded-md text-sm">
          <option value="all">All Routes</option>
          <option value="cuny-serving">CUNY-Serving Routes</option>
          <option value="top-violators">Top Violator Routes</option>
        </select>
      </div>

      <button id="reset-zoom" class="px-4 py-2 bg-gray-600 text-white rounded-md text-sm hover:bg-gray-700 transition-colors">
        Reset Zoom
      </button>
    </div>
  )}

  <!-- Chart Container -->
  <div class="relative">
    <div id="chart-container" style={`height: ${height}px;`} class="w-full">
      <!-- D3 visualization will be rendered here -->
    </div>

    <!-- Tooltip -->
    <div id="temporal-tooltip" class="absolute pointer-events-none opacity-0 bg-gray-900 text-white text-sm rounded-lg p-3 shadow-lg transition-opacity duration-200 z-10">
      <!-- Tooltip content -->
    </div>

    <!-- Time Period Highlights -->
    <div class="absolute top-4 left-4 bg-white bg-opacity-90 backdrop-blur-sm rounded-lg p-3 shadow-sm">
      <div class="text-sm font-medium text-gray-800 mb-2">Key Periods</div>
      <div class="space-y-1 text-xs">
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 bg-blue-500 rounded"></div>
          <span>Morning Rush (7-9 AM)</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 bg-orange-500 rounded"></div>
          <span>Class Hours (8 AM-6 PM)</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 bg-green-500 rounded"></div>
          <span>Evening Rush (5-7 PM)</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 bg-gray-500 rounded"></div>
          <span>Off-Peak</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Analysis Panel -->
  <div class="mt-6 grid md:grid-cols-3 gap-4">
    <div class="bg-blue-50 rounded-lg p-4">
      <h4 class="font-semibold text-blue-900 mb-2">Peak Violation Time</h4>
      <div id="peak-time" class="text-2xl font-bold text-blue-700">--:--</div>
      <div id="peak-violations" class="text-sm text-blue-600">--- violations</div>
    </div>

    <div class="bg-green-50 rounded-lg p-4">
      <h4 class="font-semibold text-green-900 mb-2">Most Effective Hour</h4>
      <div id="effective-time" class="text-2xl font-bold text-green-700">--:--</div>
      <div id="effective-rate" class="text-sm text-green-600">---% ticketing rate</div>
    </div>

    <div class="bg-orange-50 rounded-lg p-4">
      <h4 class="font-semibold text-orange-900 mb-2">Class Hour Impact</h4>
      <div id="class-impact" class="text-2xl font-bold text-orange-700">---%</div>
      <div class="text-sm text-orange-600">of daily violations</div>
    </div>
  </div>

  <!-- Selected Time Details -->
  <div id="time-details" class="mt-6 bg-gray-50 rounded-lg p-4 hidden">
    <h4 class="font-semibold text-gray-900 mb-3">Selected Time Period Analysis</h4>
    <div class="grid md:grid-cols-2 gap-6">
      <div>
        <h5 class="font-medium text-gray-700 mb-2">Time Range</h5>
        <div id="selected-range" class="text-sm text-gray-600"></div>
      </div>
      <div>
        <h5 class="font-medium text-gray-700 mb-2">Statistics</h5>
        <div id="selected-stats" class="text-sm text-gray-600 space-y-1"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
  class TemporalPatternAnalyzer {
    constructor() {
      this.data = [];
      this.processedData = [];
      this.svg = null;
      this.tooltip = null;
      this.currentView = 'heatmap';
      this.currentMetric = 'violations';
      this.selectedTimeRange = null;

      this.margin = { top: 60, right: 80, bottom: 60, left: 80 };
      this.width = 800 - this.margin.left - this.margin.right;
      this.height = 400 - this.margin.top - this.margin.bottom;

      this.days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      this.hours = Array.from({ length: 24 }, (_, i) => i);

      this.init();
    }

    async init() {
      await this.waitForDataLoader();
      await this.loadData();
      this.setupEventListeners();
      this.initializeChart();
      this.renderVisualization();
      this.updateAnalysisPanel();
    }

    async waitForDataLoader() {
      return new Promise((resolve) => {
        if (window.ClearLaneData) {
          resolve();
        } else {
          window.addEventListener('clearlane-data-ready', resolve);
        }
      });
    }

    async loadData() {
      try {
        // Load hourly aggregated data
        this.data = await window.ClearLaneData.loadDataset('hourly_agg.csv');
        console.log('Temporal data loaded:', this.data.length, 'records');

        // Process data for heatmap
        this.processData();
      } catch (error) {
        console.error('Failed to load temporal data:', error);
      }
    }

    processData() {
      // Create heatmap matrix
      this.processedData = [];

      this.days.forEach((day, dayIndex) => {
        this.hours.forEach(hour => {
          const record = this.data.find(d =>
            d.weekday === day && d.hour === hour
          );

          const violations = record ? record.violations : 0;

          // Calculate derived metrics
          const ticketingRate = this.calculateTicketingRate(violations, hour);
          const effectiveness = this.calculateEffectiveness(violations, hour, day);

          this.processedData.push({
            day: day,
            dayIndex: dayIndex,
            hour: hour,
            violations: violations,
            ticketingRate: ticketingRate,
            effectiveness: effectiveness,
            period: this.getTimePeriod(hour)
          });
        });
      });
    }

    calculateTicketingRate(violations, hour) {
      // Mock calculation - in real implementation this would use actual ticketing data
      const baseRate = 0.77; // 77% from the analysis
      const hourAdjustment = Math.sin((hour - 6) * Math.PI / 12) * 0.2; // Peak at midday
      return Math.max(0.1, Math.min(1.0, baseRate + hourAdjustment));
    }

    calculateEffectiveness(violations, hour, day) {
      // Mock effectiveness calculation based on violations and time
      const isWeekend = ['Saturday', 'Sunday'].includes(day);
      const isPeakHour = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);

      let effectiveness = 0.8; // Base effectiveness
      if (isWeekend) effectiveness *= 0.7;
      if (isPeakHour && violations > 30000) effectiveness *= 0.6;

      return effectiveness;
    }

    getTimePeriod(hour) {
      if (hour >= 7 && hour <= 9) return 'morning-rush';
      if (hour >= 17 && hour <= 19) return 'evening-rush';
      if (hour >= 8 && hour <= 18) return 'class-hours';
      return 'off-peak';
    }

    setupEventListeners() {
      document.getElementById('chart-type')?.addEventListener('change', (e) => {
        this.currentView = e.target.value;
        this.renderVisualization();
      });

      document.getElementById('metric-type')?.addEventListener('change', (e) => {
        this.currentMetric = e.target.value;
        this.renderVisualization();
      });

      document.getElementById('route-filter')?.addEventListener('change', (e) => {
        // Filter data by route type
        this.renderVisualization();
      });

      document.getElementById('reset-zoom')?.addEventListener('click', () => {
        this.resetZoom();
      });
    }

    initializeChart() {
      const container = d3.select('#chart-container');
      container.selectAll('*').remove();

      this.svg = container
        .append('svg')
        .attr('width', this.width + this.margin.left + this.margin.right)
        .attr('height', this.height + this.margin.top + this.margin.bottom);

      this.chartGroup = this.svg
        .append('g')
        .attr('transform', `translate(${this.margin.left},${this.margin.top})`);

      this.tooltip = d3.select('#temporal-tooltip');
    }

    renderVisualization() {
      switch (this.currentView) {
        case 'heatmap':
          this.renderHeatmap();
          break;
        case 'hourly':
          this.renderHourlyChart();
          break;
        case 'daily':
          this.renderDailyChart();
          break;
        case 'effectiveness':
          this.renderEffectivenessChart();
          break;
      }
    }

    renderHeatmap() {
      this.chartGroup.selectAll('*').remove();

      const xScale = d3.scaleBand()
        .domain(this.hours)
        .range([0, this.width])
        .padding(0.05);

      const yScale = d3.scaleBand()
        .domain(this.days)
        .range([0, this.height])
        .padding(0.05);

      // Color scale based on current metric
      const values = this.processedData.map(d => d[this.currentMetric]);
      const colorScale = d3.scaleSequential()
        .domain(d3.extent(values))
        .interpolator(d3.interpolateYlOrRd);

      // Create heatmap rectangles
      this.chartGroup.selectAll('.cell')
        .data(this.processedData)
        .enter()
        .append('rect')
        .attr('class', 'cell')
        .attr('x', d => xScale(d.hour))
        .attr('y', d => yScale(d.day))
        .attr('width', xScale.bandwidth())
        .attr('height', yScale.bandwidth())
        .attr('fill', d => colorScale(d[this.currentMetric]))
        .attr('stroke', '#fff')
        .attr('stroke-width', 1)
        .style('cursor', 'pointer')
        .on('mouseover', (event, d) => this.showTooltip(event, d))
        .on('mousemove', (event, d) => this.updateTooltip(event, d))
        .on('mouseout', () => this.hideTooltip())
        .on('click', (event, d) => this.selectTimeCell(d));

      // Add axes
      this.chartGroup.append('g')
        .attr('transform', `translate(0, ${this.height})`)
        .call(d3.axisBottom(xScale))
        .append('text')
        .attr('x', this.width / 2)
        .attr('y', 40)
        .attr('fill', 'black')
        .style('text-anchor', 'middle')
        .text('Hour of Day');

      this.chartGroup.append('g')
        .call(d3.axisLeft(yScale))
        .append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -50)
        .attr('x', -this.height / 2)
        .attr('fill', 'black')
        .style('text-anchor', 'middle')
        .text('Day of Week');

      // Add title
      this.chartGroup.append('text')
        .attr('x', this.width / 2)
        .attr('y', -30)
        .attr('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text(`${this.getMetricLabel()} by Hour and Day`);

      // Add color legend
      this.addColorLegend(colorScale, values);

      // Add period overlays
      this.addPeriodOverlays(xScale, yScale);
    }

    renderHourlyChart() {
      this.chartGroup.selectAll('*').remove();

      // Aggregate data by hour
      const hourlyData = this.hours.map(hour => {
        const hourRecords = this.processedData.filter(d => d.hour === hour);
        const total = d3.sum(hourRecords, d => d[this.currentMetric]);
        const avg = total / hourRecords.length;

        return {
          hour: hour,
          value: avg,
          period: this.getTimePeriod(hour)
        };
      });

      const xScale = d3.scaleLinear()
        .domain([0, 23])
        .range([0, this.width]);

      const yScale = d3.scaleLinear()
        .domain([0, d3.max(hourlyData, d => d.value)])
        .nice()
        .range([this.height, 0]);

      // Create line
      const line = d3.line()
        .x(d => xScale(d.hour))
        .y(d => yScale(d.value))
        .curve(d3.curveMonotoneX);

      // Add line
      this.chartGroup.append('path')
        .datum(hourlyData)
        .attr('fill', 'none')
        .attr('stroke', '#2563eb')
        .attr('stroke-width', 3)
        .attr('d', line);

      // Add dots
      this.chartGroup.selectAll('.dot')
        .data(hourlyData)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('cx', d => xScale(d.hour))
        .attr('cy', d => yScale(d.value))
        .attr('r', 4)
        .attr('fill', d => this.getPeriodColor(d.period))
        .style('cursor', 'pointer')
        .on('mouseover', (event, d) => this.showHourlyTooltip(event, d))
        .on('mouseout', () => this.hideTooltip());

      // Add axes
      this.chartGroup.append('g')
        .attr('transform', `translate(0, ${this.height})`)
        .call(d3.axisBottom(xScale).tickFormat(d => `${d}:00`));

      this.chartGroup.append('g')
        .call(d3.axisLeft(yScale));

      // Add title
      this.chartGroup.append('text')
        .attr('x', this.width / 2)
        .attr('y', -30)
        .attr('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text(`${this.getMetricLabel()} by Hour of Day`);
    }

    renderDailyChart() {
      this.chartGroup.selectAll('*').remove();

      // Aggregate data by day
      const dailyData = this.days.map(day => {
        const dayRecords = this.processedData.filter(d => d.day === day);
        const total = d3.sum(dayRecords, d => d[this.currentMetric]);
        const avg = total / dayRecords.length;

        return {
          day: day,
          value: avg,
          isWeekend: ['Saturday', 'Sunday'].includes(day)
        };
      });

      const xScale = d3.scaleBand()
        .domain(this.days)
        .range([0, this.width])
        .padding(0.1);

      const yScale = d3.scaleLinear()
        .domain([0, d3.max(dailyData, d => d.value)])
        .nice()
        .range([this.height, 0]);

      // Create bars
      this.chartGroup.selectAll('.bar')
        .data(dailyData)
        .enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', d => xScale(d.day))
        .attr('y', d => yScale(d.value))
        .attr('width', xScale.bandwidth())
        .attr('height', d => this.height - yScale(d.value))
        .attr('fill', d => d.isWeekend ? '#ef4444' : '#3b82f6')
        .style('cursor', 'pointer')
        .on('mouseover', (event, d) => this.showDailyTooltip(event, d))
        .on('mouseout', () => this.hideTooltip());

      // Add axes
      this.chartGroup.append('g')
        .attr('transform', `translate(0, ${this.height})`)
        .call(d3.axisBottom(xScale));

      this.chartGroup.append('g')
        .call(d3.axisLeft(yScale));

      // Add title
      this.chartGroup.append('text')
        .attr('x', this.width / 2)
        .attr('y', -30)
        .attr('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text(`${this.getMetricLabel()} by Day of Week`);
    }

    renderEffectivenessChart() {
      this.chartGroup.selectAll('*').remove();

      // Create effectiveness timeline
      const effectivenessData = this.processedData.filter(d => d.day === 'Monday'); // Show Monday as example

      const xScale = d3.scaleLinear()
        .domain([0, 23])
        .range([0, this.width]);

      const yScale = d3.scaleLinear()
        .domain([0, 1])
        .range([this.height, 0]);

      // Create area chart
      const area = d3.area()
        .x(d => xScale(d.hour))
        .y0(this.height)
        .y1(d => yScale(d.effectiveness))
        .curve(d3.curveMonotoneX);

      this.chartGroup.append('path')
        .datum(effectivenessData)
        .attr('fill', '#10b981')
        .attr('fill-opacity', 0.3)
        .attr('d', area);

      // Add effectiveness line
      const line = d3.line()
        .x(d => xScale(d.hour))
        .y(d => yScale(d.effectiveness))
        .curve(d3.curveMonotoneX);

      this.chartGroup.append('path')
        .datum(effectivenessData)
        .attr('fill', 'none')
        .attr('stroke', '#10b981')
        .attr('stroke-width', 3)
        .attr('d', line);

      // Add axes
      this.chartGroup.append('g')
        .attr('transform', `translate(0, ${this.height})`)
        .call(d3.axisBottom(xScale).tickFormat(d => `${d}:00`));

      this.chartGroup.append('g')
        .call(d3.axisLeft(yScale).tickFormat(d3.format('.0%')));

      // Add title
      this.chartGroup.append('text')
        .attr('x', this.width / 2)
        .attr('y', -30)
        .attr('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text('Enforcement Effectiveness Throughout Day');
    }

    addColorLegend(colorScale, values) {
      const legendWidth = 200;
      const legendHeight = 20;

      const legend = this.svg.append('g')
        .attr('transform', `translate(${this.width + this.margin.left + 20}, ${this.margin.top})`);

      // Create gradient
      const defs = this.svg.append('defs');
      const gradient = defs.append('linearGradient')
        .attr('id', 'legend-gradient')
        .attr('x1', '0%')
        .attr('x2', '100%');

      gradient.selectAll('stop')
        .data(colorScale.ticks().map((t, i, n) => ({ offset: `${100*i/n.length}%`, color: colorScale(t) })))
        .enter()
        .append('stop')
        .attr('offset', d => d.offset)
        .attr('stop-color', d => d.color);

      legend.append('rect')
        .attr('width', legendWidth)
        .attr('height', legendHeight)
        .style('fill', 'url(#legend-gradient)');

      // Add scale
      const legendScale = d3.scaleLinear()
        .domain(d3.extent(values))
        .range([0, legendWidth]);

      legend.append('g')
        .attr('transform', `translate(0, ${legendHeight})`)
        .call(d3.axisBottom(legendScale).ticks(5));

      legend.append('text')
        .attr('x', legendWidth / 2)
        .attr('y', -5)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text(this.getMetricLabel());
    }

    addPeriodOverlays(xScale, yScale) {
      // Add subtle overlays for different time periods
      const periods = [
        { name: 'Morning Rush', hours: [7, 8, 9], color: '#3b82f6', opacity: 0.1 },
        { name: 'Evening Rush', hours: [17, 18, 19], color: '#10b981', opacity: 0.1 },
        { name: 'Class Hours', hours: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], color: '#f59e0b', opacity: 0.05 }
      ];

      periods.forEach(period => {
        period.hours.forEach(hour => {
          this.chartGroup.append('rect')
            .attr('x', xScale(hour))
            .attr('y', 0)
            .attr('width', xScale.bandwidth())
            .attr('height', this.height)
            .attr('fill', period.color)
            .attr('opacity', period.opacity)
            .attr('pointer-events', 'none');
        });
      });
    }

    getPeriodColor(period) {
      const colors = {
        'morning-rush': '#3b82f6',
        'evening-rush': '#10b981',
        'class-hours': '#f59e0b',
        'off-peak': '#6b7280'
      };
      return colors[period] || '#6b7280';
    }

    getMetricLabel() {
      const labels = {
        'violations': 'Total Violations',
        'ticketingRate': 'Ticketing Rate (%)',
        'effectiveness': 'Enforcement Effectiveness'
      };
      return labels[this.currentMetric] || 'Value';
    }

    showTooltip(event, d) {
      this.tooltip
        .style('opacity', 1)
        .html(`
          <div class="font-semibold">${d.day}, ${d.hour}:00</div>
          <div>Violations: ${d.violations.toLocaleString()}</div>
          <div>Ticketing Rate: ${(d.ticketingRate * 100).toFixed(1)}%</div>
          <div>Effectiveness: ${(d.effectiveness * 100).toFixed(1)}%</div>
          <div class="text-xs mt-1 opacity-75">Period: ${d.period}</div>
        `);

      this.updateTooltip(event);
    }

    showHourlyTooltip(event, d) {
      this.tooltip
        .style('opacity', 1)
        .html(`
          <div class="font-semibold">${d.hour}:00</div>
          <div>${this.getMetricLabel()}: ${d.value.toLocaleString()}</div>
          <div class="text-xs mt-1 opacity-75">Period: ${d.period}</div>
        `);

      this.updateTooltip(event);
    }

    showDailyTooltip(event, d) {
      this.tooltip
        .style('opacity', 1)
        .html(`
          <div class="font-semibold">${d.day}</div>
          <div>${this.getMetricLabel()}: ${d.value.toLocaleString()}</div>
          <div class="text-xs mt-1 opacity-75">${d.isWeekend ? 'Weekend' : 'Weekday'}</div>
        `);

      this.updateTooltip(event);
    }

    updateTooltip(event) {
      const rect = document.getElementById('chart-container').getBoundingClientRect();
      this.tooltip
        .style('left', (event.clientX - rect.left + 10) + 'px')
        .style('top', (event.clientY - rect.top - 10) + 'px');
    }

    hideTooltip() {
      this.tooltip.style('opacity', 0);
    }

    selectTimeCell(d) {
      this.selectedTimeRange = d;
      this.showTimeDetails(d);

      // Highlight selected cell
      this.chartGroup.selectAll('.cell')
        .attr('stroke-width', cell => cell === d ? 3 : 1)
        .attr('stroke', cell => cell === d ? '#1f2937' : '#fff');
    }

    showTimeDetails(d) {
      const detailsContainer = document.getElementById('time-details');
      const rangeElement = document.getElementById('selected-range');
      const statsElement = document.getElementById('selected-stats');

      rangeElement.innerHTML = `${d.day}, ${d.hour}:00 - ${d.hour + 1}:00`;

      statsElement.innerHTML = `
        <div>Violations: ${d.violations.toLocaleString()}</div>
        <div>Ticketing Rate: ${(d.ticketingRate * 100).toFixed(1)}%</div>
        <div>Effectiveness: ${(d.effectiveness * 100).toFixed(1)}%</div>
        <div>Time Period: ${d.period.replace('-', ' ')}</div>
      `;

      detailsContainer.classList.remove('hidden');
    }

    updateAnalysisPanel() {
      // Find peak violation time
      const peakViolation = this.processedData.reduce((max, curr) =>
        curr.violations > max.violations ? curr : max
      );

      document.getElementById('peak-time').textContent = `${peakViolation.hour}:00`;
      document.getElementById('peak-violations').textContent = peakViolation.violations.toLocaleString();

      // Find most effective time
      const mostEffective = this.processedData.reduce((max, curr) =>
        curr.effectiveness > max.effectiveness ? curr : max
      );

      document.getElementById('effective-time').textContent = `${mostEffective.hour}:00`;
      document.getElementById('effective-rate').textContent = `${(mostEffective.ticketingRate * 100).toFixed(1)}%`;

      // Calculate class hour impact
      const classHourViolations = this.processedData
        .filter(d => d.period === 'class-hours')
        .reduce((sum, d) => sum + d.violations, 0);

      const totalViolations = this.processedData
        .reduce((sum, d) => sum + d.violations, 0);

      const classImpactPercent = ((classHourViolations / totalViolations) * 100).toFixed(1);
      document.getElementById('class-impact').textContent = `${classImpactPercent}%`;
    }

    resetZoom() {
      // Reset any zoom/selection state
      this.selectedTimeRange = null;
      document.getElementById('time-details').classList.add('hidden');

      this.chartGroup.selectAll('.cell')
        .attr('stroke-width', 1)
        .attr('stroke', '#fff');
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new TemporalPatternAnalyzer();
  });
</script>

<style>
  /* Chart-specific styles */
  .cell:hover {
    opacity: 0.8;
  }

  .dot:hover {
    r: 6;
  }

  .bar:hover {
    opacity: 0.8;
  }

  /* Tooltip styles */
  #temporal-tooltip {
    max-width: 200px;
    font-size: 12px;
    line-height: 1.4;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    #chart-container svg {
      width: 100%;
      height: auto;
    }
  }
</style>