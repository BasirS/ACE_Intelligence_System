---
// Performance Optimizer - Lazy loading, progressive enhancement, and optimization
// Ensures fast loading and smooth interactions for data-heavy visualizations
export interface PerformanceProps {
  enableLazyLoading?: boolean;
  enableProgressiveEnhancement?: boolean;
  enableDataSampling?: boolean;
  enableServiceWorker?: boolean;
}

interface Props extends PerformanceProps {}

const {
  enableLazyLoading = true,
  enableProgressiveEnhancement = true,
  enableDataSampling = true,
  enableServiceWorker = true
} = Astro.props;
---

<!-- Performance monitoring and optimization -->
<div id="performance-optimizer" class="hidden" data-config={JSON.stringify({
  enableLazyLoading,
  enableProgressiveEnhancement,
  enableDataSampling,
  enableServiceWorker
})}>
</div>

<!-- Loading indicators for progressive enhancement -->
<template id="loading-indicator-template">
  <div class="flex items-center justify-center p-8">
    <div class="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
    <span class="ml-3 text-gray-600">Loading visualization...</span>
  </div>
</template>

<!-- Error fallback template -->
<template id="error-fallback-template">
  <div class="flex items-center justify-center p-8 bg-gray-50 border border-gray-200 rounded-lg">
    <div class="text-center">
      <svg class="w-12 h-12 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      <h3 class="text-lg font-medium text-gray-900 mb-2">Visualization Unavailable</h3>
      <p class="text-sm text-gray-600 mb-4">Unable to load interactive visualization.</p>
      <button class="px-4 py-2 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700 transition-colors"
              onclick="this.closest('[data-component]').dispatchEvent(new CustomEvent('retry-load'))">
        Retry
      </button>
    </div>
  </div>
</template>

<script>
  class PerformanceOptimizer {
    constructor() {
      this.config = JSON.parse(
        document.getElementById('performance-optimizer')?.dataset.config || '{}'
      );

      this.intersectionObserver = null;
      this.loadingComponents = new Set();
      this.loadedComponents = new Set();
      this.errorComponents = new Set();

      // Performance metrics
      this.metrics = {
        pageLoadTime: performance.now(),
        componentLoadTimes: new Map(),
        dataLoadTimes: new Map(),
        interactionTimes: new Map()
      };

      this.init();
    }

    init() {
      this.setupLazyLoading();
      this.setupProgressiveEnhancement();
      this.setupDataSampling();
      this.setupServiceWorker();
      this.setupPerformanceMonitoring();
      this.setupErrorHandling();

      console.log('Performance Optimizer initialized with config:', this.config);
    }

    setupLazyLoading() {
      if (!this.config.enableLazyLoading) return;

      // Create intersection observer for lazy loading
      this.intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.loadComponent(entry.target);
            this.intersectionObserver.unobserve(entry.target);
          }
        });
      }, {
        root: null,
        rootMargin: '100px', // Load 100px before coming into view
        threshold: 0.1
      });

      // Observe all lazy-loadable components
      this.observeLazyComponents();

      // Set up mutation observer for dynamically added components
      const mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const lazyComponents = node.querySelectorAll('[data-lazy-load]');
              lazyComponents.forEach(component => {
                this.observeComponent(component);
              });
            }
          });
        });
      });

      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    observeLazyComponents() {
      const lazyComponents = document.querySelectorAll('[data-lazy-load]');
      lazyComponents.forEach(component => {
        this.observeComponent(component);
      });
    }

    observeComponent(component) {
      if (!component.hasAttribute('data-observed')) {
        component.setAttribute('data-observed', 'true');

        // Add loading indicator
        this.showLoadingIndicator(component);

        // Observe for intersection
        this.intersectionObserver.observe(component);
      }
    }

    showLoadingIndicator(component) {
      const template = document.getElementById('loading-indicator-template');
      if (template) {
        const indicator = template.content.cloneNode(true);
        component.appendChild(indicator);
      }
    }

    hideLoadingIndicator(component) {
      const indicator = component.querySelector('.animate-spin')?.closest('div');
      if (indicator) {
        indicator.remove();
      }
    }

    async loadComponent(component) {
      const componentName = component.dataset.component;
      const startTime = performance.now();

      this.loadingComponents.add(componentName);

      try {
        // Simulate component loading - in real implementation, this would load the actual component
        await this.loadComponentAssets(component);

        // Initialize the component
        await this.initializeComponent(component);

        // Mark as loaded
        this.loadingComponents.delete(componentName);
        this.loadedComponents.add(componentName);

        // Hide loading indicator
        this.hideLoadingIndicator(component);

        // Record load time
        const loadTime = performance.now() - startTime;
        this.metrics.componentLoadTimes.set(componentName, loadTime);

        // Dispatch loaded event
        component.dispatchEvent(new CustomEvent('component-loaded', {
          detail: { componentName, loadTime }
        }));

        console.log(`Component ${componentName} loaded in ${loadTime.toFixed(2)}ms`);

      } catch (error) {
        console.error(`Failed to load component ${componentName}:`, error);

        this.loadingComponents.delete(componentName);
        this.errorComponents.add(componentName);

        this.showErrorFallback(component);

        // Dispatch error event
        component.dispatchEvent(new CustomEvent('component-error', {
          detail: { componentName, error }
        }));
      }
    }

    async loadComponentAssets(component) {
      const componentType = component.dataset.component;

      // Load different assets based on component type
      switch (componentType) {
        case 'personal-journey-timeline':
          await this.loadD3Assets();
          break;

        case 'violation-hotspot-explorer':
          await this.loadMapAssets();
          break;

        case 'temporal-pattern-analyzer':
          await this.loadD3Assets();
          break;

        case 'cuny-impact-calculator':
          await this.loadD3Assets();
          break;

        case 'clearlane-target-list':
          // Basic component, no additional assets needed
          break;

        default:
          console.warn(`Unknown component type: ${componentType}`);
      }
    }

    async loadD3Assets() {
      if (!window.d3) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://d3js.org/d3.v7.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }
    }

    async loadMapAssets() {
      if (!window.L) {
        const promises = [];

        // Load Leaflet CSS
        const cssLink = document.createElement('link');
        cssLink.rel = 'stylesheet';
        cssLink.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(cssLink);

        // Load Leaflet JS
        promises.push(new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        }));

        // Load Leaflet Heat plugin
        promises.push(new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        }));

        await Promise.all(promises);
      }
    }

    async initializeComponent(component) {
      const componentType = component.dataset.component;

      // Initialize component based on type
      switch (componentType) {
        case 'personal-journey-timeline':
          if (window.PersonalJourneyTimeline) {
            new window.PersonalJourneyTimeline(component);
          }
          break;

        case 'violation-hotspot-explorer':
          if (window.ViolationHotspotExplorer) {
            new window.ViolationHotspotExplorer(component);
          }
          break;

        case 'temporal-pattern-analyzer':
          if (window.TemporalPatternAnalyzer) {
            new window.TemporalPatternAnalyzer(component);
          }
          break;

        case 'cuny-impact-calculator':
          if (window.CUNYImpactCalculator) {
            new window.CUNYImpactCalculator(component);
          }
          break;

        case 'clearlane-target-list':
          if (window.ClearLaneTargetList) {
            new window.ClearLaneTargetList(component);
          }
          break;
      }
    }

    showErrorFallback(component) {
      const template = document.getElementById('error-fallback-template');
      if (template) {
        // Clear existing content
        component.innerHTML = '';

        // Add error fallback
        const fallback = template.content.cloneNode(true);
        component.appendChild(fallback);

        // Setup retry handler
        component.addEventListener('retry-load', () => {
          this.retryLoadComponent(component);
        });
      }
    }

    retryLoadComponent(component) {
      const componentName = component.dataset.component;

      // Clear error state
      this.errorComponents.delete(componentName);

      // Clear component content
      component.innerHTML = '';

      // Restart loading process
      this.showLoadingIndicator(component);
      this.loadComponent(component);
    }

    setupProgressiveEnhancement() {
      if (!this.config.enableProgressiveEnhancement) return;

      // Detect capabilities
      const capabilities = this.detectCapabilities();

      // Apply progressive enhancement based on capabilities
      this.applyProgresiveEnhancement(capabilities);
    }

    detectCapabilities() {
      return {
        webgl: !!document.createElement('canvas').getContext('webgl'),
        intersectionObserver: 'IntersectionObserver' in window,
        requestIdleCallback: 'requestIdleCallback' in window,
        serviceWorker: 'serviceWorker' in navigator,
        localStorage: (() => {
          try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            return true;
          } catch {
            return false;
          }
        })(),
        connectionSpeed: navigator.connection ? navigator.connection.effectiveType : 'unknown'
      };
    }

    applyProgresiveEnhancement(capabilities) {
      // Adjust features based on capabilities
      if (!capabilities.webgl) {
        // Disable WebGL-based visualizations, use canvas fallbacks
        document.documentElement.classList.add('no-webgl');
      }

      if (!capabilities.intersectionObserver) {
        // Fallback to scroll-based lazy loading
        this.setupScrollBasedLazyLoading();
      }

      if (capabilities.connectionSpeed === 'slow-2g' || capabilities.connectionSpeed === '2g') {
        // Enable data sampling for slow connections
        document.documentElement.classList.add('slow-connection');
        this.enableAggressiveDataSampling();
      }

      console.log('Progressive enhancement applied:', capabilities);
    }

    setupScrollBasedLazyLoading() {
      let ticking = false;

      const checkVisibility = () => {
        const components = document.querySelectorAll('[data-lazy-load]:not([data-loaded])');

        components.forEach(component => {
          const rect = component.getBoundingClientRect();
          const isVisible = rect.top < window.innerHeight + 100 && rect.bottom > -100;

          if (isVisible) {
            this.loadComponent(component);
            component.setAttribute('data-loaded', 'true');
          }
        });

        ticking = false;
      };

      const onScroll = () => {
        if (!ticking) {
          requestAnimationFrame(checkVisibility);
          ticking = true;
        }
      };

      window.addEventListener('scroll', onScroll, { passive: true });
    }

    setupDataSampling() {
      if (!this.config.enableDataSampling) return;

      // Create data sampling utility
      window.ClearLaneDataSampler = {
        sampleSize: this.getOptimalSampleSize(),

        sampleData: (data, maxSize = null) => {
          const targetSize = maxSize || this.getOptimalSampleSize();

          if (data.length <= targetSize) {
            return data;
          }

          // Use systematic sampling for better representation
          const step = Math.floor(data.length / targetSize);
          const sampled = [];

          for (let i = 0; i < data.length; i += step) {
            sampled.push(data[i]);
            if (sampled.length >= targetSize) break;
          }

          return sampled;
        },

        adaptiveSample: (data, complexity) => {
          // Adjust sample size based on visualization complexity
          let sampleMultiplier = 1;

          if (complexity === 'high') sampleMultiplier = 0.5;
          else if (complexity === 'medium') sampleMultiplier = 0.7;

          return this.sampleData(data, Math.floor(this.getOptimalSampleSize() * sampleMultiplier));
        }
      };
    }

    getOptimalSampleSize() {
      // Determine optimal sample size based on device capabilities
      const deviceMemory = navigator.deviceMemory || 4; // GB
      const connectionSpeed = navigator.connection?.effectiveType || '4g';

      let baseSize = 1000;

      // Adjust based on memory
      if (deviceMemory >= 8) baseSize = 2000;
      else if (deviceMemory <= 2) baseSize = 500;

      // Adjust based on connection
      if (connectionSpeed === 'slow-2g' || connectionSpeed === '2g') {
        baseSize *= 0.3;
      } else if (connectionSpeed === '3g') {
        baseSize *= 0.7;
      }

      return Math.floor(baseSize);
    }

    enableAggressiveDataSampling() {
      // For slow connections, use very aggressive sampling
      window.ClearLaneDataSampler.sampleSize = 200;

      // Add visual indicator for reduced data
      const indicator = document.createElement('div');
      indicator.className = 'fixed bottom-4 left-4 bg-orange-100 border border-orange-300 text-orange-800 px-3 py-2 rounded-lg text-sm z-30';
      indicator.innerHTML = '⚡ Data optimized for your connection';
      document.body.appendChild(indicator);

      // Auto-hide after 5 seconds
      setTimeout(() => indicator.remove(), 5000);
    }

    setupServiceWorker() {
      if (!this.config.enableServiceWorker || !('serviceWorker' in navigator)) return;

      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          console.log('Service Worker registered:', registration);

          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                this.showUpdateAvailable();
              }
            });
          });
        })
        .catch(error => {
          console.error('Service Worker registration failed:', error);
        });
    }

    showUpdateAvailable() {
      const banner = document.createElement('div');
      banner.className = 'fixed top-0 left-0 right-0 bg-blue-600 text-white p-3 text-center z-50';
      banner.innerHTML = `
        <span>A new version is available!</span>
        <button onclick="window.location.reload()" class="ml-4 px-3 py-1 bg-white text-blue-600 rounded text-sm">
          Update
        </button>
        <button onclick="this.parentElement.remove()" class="ml-2 text-blue-200 hover:text-white">
          ×
        </button>
      `;
      document.body.prepend(banner);
    }

    setupPerformanceMonitoring() {
      // Monitor Core Web Vitals
      this.monitorWebVitals();

      // Monitor custom metrics
      this.monitorCustomMetrics();

      // Setup performance observer
      if ('PerformanceObserver' in window) {
        this.setupPerformanceObserver();
      }
    }

    monitorWebVitals() {
      // Measure LCP (Largest Contentful Paint)
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'largest-contentful-paint') {
            this.metrics.lcp = entry.startTime;
            console.log('LCP:', entry.startTime);
          }
        }
      }).observe({ entryTypes: ['largest-contentful-paint'] });

      // Measure FID (First Input Delay)
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'first-input') {
            this.metrics.fid = entry.processingStart - entry.startTime;
            console.log('FID:', this.metrics.fid);
          }
        }
      }).observe({ entryTypes: ['first-input'] });

      // Measure CLS (Cumulative Layout Shift)
      new PerformanceObserver((list) => {
        let clsScore = 0;
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            clsScore += entry.value;
          }
        }
        this.metrics.cls = clsScore;
        console.log('CLS:', clsScore);
      }).observe({ entryTypes: ['layout-shift'] });
    }

    monitorCustomMetrics() {
      // Time to Interactive for components
      document.addEventListener('component-loaded', (e) => {
        const { componentName, loadTime } = e.detail;
        this.metrics.componentLoadTimes.set(componentName, loadTime);

        // Log if component takes too long
        if (loadTime > 3000) {
          console.warn(`Slow component load: ${componentName} took ${loadTime}ms`);
        }
      });

      // Data loading times
      window.addEventListener('clearlane-data-ready', () => {
        this.metrics.dataLoadTime = performance.now() - this.metrics.pageLoadTime;
        console.log('Data ready in:', this.metrics.dataLoadTime, 'ms');
      });

      // Interaction responsiveness
      this.setupInteractionMonitoring();
    }

    setupInteractionMonitoring() {
      let interactionStart = 0;

      ['click', 'keydown', 'touchstart'].forEach(eventType => {
        document.addEventListener(eventType, () => {
          interactionStart = performance.now();
        }, { passive: true });
      });

      // Monitor when DOM updates complete
      const observer = new MutationObserver(() => {
        if (interactionStart > 0) {
          const responseTime = performance.now() - interactionStart;

          if (responseTime > 100) {
            console.warn('Slow interaction response:', responseTime, 'ms');
          }

          interactionStart = 0;
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true
      });
    }

    setupPerformanceObserver() {
      // Monitor long tasks
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 50) {
            console.warn('Long task detected:', entry.duration, 'ms');
          }
        }
      }).observe({ entryTypes: ['longtask'] });

      // Monitor resource loading
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 1000) {
            console.warn('Slow resource load:', entry.name, entry.duration, 'ms');
          }
        }
      }).observe({ entryTypes: ['resource'] });
    }

    setupErrorHandling() {
      // Global error handler
      window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        this.handleGlobalError(event.error);
      });

      // Promise rejection handler
      window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
        this.handleGlobalError(event.reason);
      });

      // Component error handler
      document.addEventListener('component-error', (event) => {
        const { componentName, error } = event.detail;
        console.error(`Component error in ${componentName}:`, error);
      });
    }

    handleGlobalError(error) {
      // In a production app, you might want to send errors to a logging service
      console.error('Handling global error:', error);

      // Show user-friendly error message if it affects critical functionality
      if (error.message?.includes('component') || error.message?.includes('data')) {
        this.showGlobalErrorMessage();
      }
    }

    showGlobalErrorMessage() {
      const errorBanner = document.createElement('div');
      errorBanner.className = 'fixed top-0 left-0 right-0 bg-red-600 text-white p-3 text-center z-50';
      errorBanner.innerHTML = `
        <span>Some features may not be working properly. Please refresh the page.</span>
        <button onclick="window.location.reload()" class="ml-4 px-3 py-1 bg-white text-red-600 rounded text-sm">
          Refresh
        </button>
        <button onclick="this.parentElement.remove()" class="ml-2 text-red-200 hover:text-white">
          ×
        </button>
      `;
      document.body.prepend(errorBanner);

      // Auto-hide after 10 seconds
      setTimeout(() => {
        if (errorBanner.parentElement) {
          errorBanner.remove();
        }
      }, 10000);
    }

    // Public API for manual component loading
    static loadComponent(selector) {
      const component = document.querySelector(selector);
      if (component && window.performanceOptimizer) {
        return window.performanceOptimizer.loadComponent(component);
      }
    }

    static getMetrics() {
      return window.performanceOptimizer?.metrics || {};
    }
  }

  // Initialize performance optimizer
  document.addEventListener('DOMContentLoaded', () => {
    window.performanceOptimizer = new PerformanceOptimizer();
  });

  // Export for global access
  window.PerformanceOptimizer = PerformanceOptimizer;
</script>

<style>
  /* Loading animations */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .animate-spin {
    animation: spin 1s linear infinite;
  }

  /* Progressive enhancement classes */
  .no-webgl .webgl-only {
    display: none;
  }

  .slow-connection .high-bandwidth-only {
    display: none;
  }

  /* Performance-related styles */
  .performance-optimized {
    contain: layout style paint;
  }

  .lazy-load-placeholder {
    min-height: 200px;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }

  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Error states */
  .error-state {
    opacity: 0.7;
    pointer-events: none;
  }

  .retry-button {
    transition: all 0.2s ease;
  }

  .retry-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
</style>